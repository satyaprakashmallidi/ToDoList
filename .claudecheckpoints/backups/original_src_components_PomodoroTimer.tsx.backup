import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useTimeStore } from '../contexts/TimeStore';

interface PomodoroTimerProps {
  size?: number;
  onPhaseChange?: (phase: 'work' | 'short' | 'long') => void;
}

interface PersistentTimerState {
  phase: 'work' | 'short' | 'long';
  isRunning: boolean;
  startedAt: number;
  elapsedMs: number;
  workCount: number;
}

const PomodoroTimer: React.FC<PomodoroTimerProps> = ({ size = 256, onPhaseChange }) => {
  const { startTimer: startTimeTracking, pauseTimer: pauseTimeTracking } = useTimeStore();
  
  const [phase, setPhase] = useState<'work' | 'short' | 'long'>('work');
  const [isRunning, setIsRunning] = useState(false);
  const [startedAt, setStartedAt] = useState(0);
  const [elapsedMs, setElapsedMs] = useState(0);
  const [workCount, setWorkCount] = useState(0);
  const [timeLeft, setTimeLeft] = useState(25 * 60);
  
  const animationFrameRef = useRef<number>();
  const audioContextRef = useRef<AudioContext | null>(null);

  const DURATIONS = {
    work: 25 * 60 * 1000, // Convert to milliseconds
    short: 5 * 60 * 1000,
    long: 15 * 60 * 1000,
    longEvery: 3
  };

  // State loaded flag to prevent multiple loads
  const [stateLoaded, setStateLoaded] = useState(false);

  // Load and reconstruct state from localStorage
  const loadState = useCallback(() => {
    if (stateLoaded) return; // Prevent multiple loads
    
    const savedState = localStorage.getItem('persistentPomodoro');
    if (savedState) {
      try {
        const state: PersistentTimerState = JSON.parse(savedState);
        const now = Date.now();
        
        setPhase(state.phase);
        setWorkCount(state.workCount);
        
        if (state.isRunning) {
          const totalElapsed = state.elapsedMs + (now - state.startedAt);
          const phaseDuration = DURATIONS[state.phase];
          
          if (totalElapsed >= phaseDuration) {
            // Timer completed while away - handle phase transition
            handlePhaseComplete(state.phase, state.workCount);
            setIsRunning(false);
            setElapsedMs(0);
            setStartedAt(0);
          } else {
            // Timer still running
            setIsRunning(true);
            setStartedAt(now);
            setElapsedMs(totalElapsed);
            
            // Resume time tracking for all phases
            if (state.phase === 'work') {
              startTimeTracking('focus');
            } else if (state.phase === 'short') {
              startTimeTracking('shortBreak');
            } else if (state.phase === 'long') {
              startTimeTracking('longBreak');
            }
          }
        } else {
          setIsRunning(false);
          setElapsedMs(state.elapsedMs);
          setStartedAt(0);
        }
      } catch (error) {
        console.log('Failed to load timer state');
      }
    }
    setStateLoaded(true);
  }, [stateLoaded, startTimeTracking]);

  useEffect(() => {
    if (!stateLoaded) {
      loadState();
    }
  }, [loadState, stateLoaded]);

  // Save state to localStorage
  const saveState = useCallback(() => {
    const state: PersistentTimerState = {
      phase,
      isRunning,
      startedAt,
      elapsedMs,
      workCount
    };
    localStorage.setItem('persistentPomodoro', JSON.stringify(state));
  }, [phase, isRunning, startedAt, elapsedMs, workCount]);

  useEffect(() => {
    saveState();
  }, [saveState]);

  // Handle phase completion and transitions
  const handlePhaseComplete = useCallback((currentPhase: 'work' | 'short' | 'long', currentWorkCount: number) => {
    playBeep();
    
    if (currentPhase === 'work') {
      // Only add work hours for completed 25-minute work sessions
      // This will be handled by the time tracking system
      const newWorkCount = currentWorkCount + 1;
      setWorkCount(newWorkCount);
      
      // Determine next phase
      const nextPhase = newWorkCount % DURATIONS.longEvery === 0 ? 'long' : 'short';
      setPhase(nextPhase);
      onPhaseChange?.(nextPhase);
    } else {
      // Break completed, return to work
      if (currentPhase === 'long') setWorkCount(0);
      setPhase('work');
      onPhaseChange?.('work');
    }
    
    setElapsedMs(0);
  }, []);

  const formatTime = (milliseconds: number): string => {
    const totalSeconds = Math.ceil(milliseconds / 1000);
    const mins = Math.floor(totalSeconds / 60);
    const secs = totalSeconds % 60;
    return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
  };

  const playBeep = () => {
    try {
      if (!audioContextRef.current) {
        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
        if (AudioContext) {
          audioContextRef.current = new AudioContext();
        }
      }

      if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
        audioContextRef.current.resume();
      }

      if (audioContextRef.current) {
        const oscillator = audioContextRef.current.createOscillator();
        const gainNode = audioContextRef.current.createGain();
        
        oscillator.frequency.setValueAtTime(880, audioContextRef.current.currentTime);
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.001, audioContextRef.current.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.25, audioContextRef.current.currentTime + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContextRef.current.currentTime + 0.65);
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContextRef.current.destination);
        
        oscillator.start(audioContextRef.current.currentTime);
        oscillator.stop(audioContextRef.current.currentTime + 0.7);
      }
    } catch (error) {
      console.log('Audio not available');
    }
  };

  // Animation loop for timer updates
  const updateTimer = useCallback(() => {
    if (isRunning && startedAt > 0) {
      const now = Date.now();
      const currentElapsed = elapsedMs + (now - startedAt);
      const phaseDuration = DURATIONS[phase];
      
      if (currentElapsed >= phaseDuration) {
        // Phase completed
        handlePhaseComplete(phase, workCount);
        setIsRunning(false);
        setElapsedMs(0);
        setStartedAt(0);
        
        // Stop time tracking for any phase when timer completes
        pauseTimeTracking();
      } else {
        // Update remaining time
        const remaining = phaseDuration - currentElapsed;
        setTimeLeft(remaining);
      }
    }
    
    if (isRunning) {
      animationFrameRef.current = requestAnimationFrame(updateTimer);
    }
  }, [isRunning, startedAt, elapsedMs, phase, workCount, handlePhaseComplete, pauseTimeTracking]);

  useEffect(() => {
    if (isRunning) {
      animationFrameRef.current = requestAnimationFrame(updateTimer);
    } else {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    }
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isRunning, updateTimer]);

  const startTimer = () => {
    const now = Date.now();
    setIsRunning(true);
    setStartedAt(now);
    
    // Start time tracking for both work and break sessions
    if (phase === 'work') {
      startTimeTracking('focus');
    } else if (phase === 'short') {
      startTimeTracking('shortBreak');
    } else if (phase === 'long') {
      startTimeTracking('longBreak');
    }
  };

  const pauseTimer = () => {
    if (isRunning) {
      const now = Date.now();
      setElapsedMs(prev => prev + (now - startedAt));
      setIsRunning(false);
      setStartedAt(0);
      
      // Pause time tracking for both work and break sessions
      pauseTimeTracking();
    }
  };

  const toggleTimer = () => {
    if (isRunning) {
      pauseTimer();
    } else {
      startTimer();
    }
  };

  // Handle visibility change to maintain accuracy
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.hidden && isRunning) {
        // Page becoming hidden - save current state
        const now = Date.now();
        setElapsedMs(prev => prev + (now - startedAt));
        setStartedAt(now);
      } else if (!document.hidden && isRunning) {
        // Page becoming visible - update start time
        setStartedAt(Date.now());
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isRunning, startedAt]);

  // Update timeLeft based on current state
  useEffect(() => {
    const phaseDuration = DURATIONS[phase];
    if (isRunning && startedAt > 0) {
      const now = Date.now();
      const currentElapsed = elapsedMs + (now - startedAt);
      const remaining = Math.max(0, phaseDuration - currentElapsed);
      setTimeLeft(remaining);
    } else {
      const remaining = phaseDuration - elapsedMs;
      setTimeLeft(Math.max(0, remaining));
    }
  }, [phase, elapsedMs, isRunning, startedAt]);

  // Calculate progress for the ring
  const totalTime = DURATIONS[phase];
  const currentElapsed = isRunning && startedAt > 0 
    ? elapsedMs + (Date.now() - startedAt)
    : elapsedMs;
  const progress = Math.min(1, currentElapsed / totalTime);
  const radius = 82;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference * (1 - progress);

  const getPhaseColor = () => {
    switch (phase) {
      case 'work': return '#2563eb';
      case 'short': return '#10b981';
      case 'long': return '#f59e0b';
      default: return '#2563eb';
    }
  };

  const getPhaseLabel = () => {
    return phase === 'work' ? 'Focus' : 'Break';
  };

  return (
    <div className="flex flex-col items-center gap-4">
      <div 
        className="relative"
        style={{ 
          width: size, 
          height: size,
          filter: 'drop-shadow(0 8px 24px rgba(0,0,0,.06))'
        }}
      >
        <svg width="100%" height="100%" viewBox="0 0 200 200">
          {/* Background track */}
          <circle
            cx="100"
            cy="100"
            r={radius}
            fill="none"
            stroke="#e5e7eb"
            strokeWidth="18"
          />
          {/* Progress ring */}
          <g transform="rotate(-90 100 100)">
            <circle
              cx="100"
              cy="100"
              r={radius}
              fill="none"
              stroke={getPhaseColor()}
              strokeWidth="18"
              strokeLinecap="round"
              strokeDasharray={circumference}
              strokeDashoffset={strokeDashoffset}
              style={{ transition: 'stroke-dashoffset 0.5s ease' }}
            />
          </g>
        </svg>
        
        {/* Timer display */}
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-center">
            <div 
              className="font-bold tracking-wider text-gray-800"
              style={{ fontSize: 'clamp(32px, 7vmin, 42px)' }}
            >
              {formatTime(timeLeft)}
            </div>
          </div>
        </div>
      </div>
      
      {/* Control button with animations */}
      <button
        onClick={toggleTimer}
        className="w-8 h-8 rounded-full border border-gray-300 bg-white flex items-center justify-center cursor-pointer transition-all duration-200 hover:bg-blue-50 hover:border-blue-300 hover:shadow-md active:scale-95"
        aria-label={isRunning ? "Pause" : "Start"}
      >
        <div className="transition-all duration-300 ease-in-out">
          {isRunning ? (
            <svg 
              width="14" 
              height="14" 
              viewBox="0 0 24 24" 
              fill="currentColor" 
              className="text-blue-600 animate-scale-in"
            >
              <path d="M7 5h4v14H7zM13 5h4v14h-4z"/>
            </svg>
          ) : (
            <svg 
              width="14" 
              height="14" 
              viewBox="0 0 24 24" 
              fill="currentColor" 
              className="text-blue-600 animate-scale-in"
            >
              <path d="M8 5v14l11-7z"/>
            </svg>
          )}
        </div>
      </button>
    </div>
  );
};

export default PomodoroTimer;